<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>DOM基本操作</title>
</head>
<body>
    <div>
        <span></span>
        <em></em>
        <strong></strong>
    </div>
    <!-- <div>
        <div>
            <em>
                <strong>
                    <span></span>
                </strong>
                <strong></strong>
                <strong></strong>
                <em></em>
                <em></em>
                <em></em>
                <span></span>
                <span></span>
            </em>
        </div>
    </div> -->

    <script>
        //遍历节点树  parentNode
        //parentNode是每一个DOM元素都有的属性, 表示该DOM元素的父亲节点
        //我们首先把span标签拿出来
        // var span = document.getElementsByTagName('span')[0];
        //> span.parentNode
        //< <strong>...</strong>

        //遍历元素节点树(在原型链上编程)
       


        //封装函数, 返回元素e的第n层祖先元素节点
        // function retParent(elem, n) {
        //     var e = document.getElementsByTagName(elem)[0];
        //     for(;n > 0;n --) {
        //         e = e.parentNode;
        //         if(e.nodeType !== 1) {
        //             console.log('越界!!!');
        //         }
        //     }
        //     return e;
        // }

        //封装函数, 返回元素e的第n个兄弟元素节点, n为正, 返回后面的兄弟元素节点, n为负, 返回前面的, n为0, 返回自己
        // function retSibling(elem, n) {
        //     if(n > 0) {
        //         while(n) {
        //             if(elem.nextSibling.nodeType == 1) {
        //                 elem = elem.nextSibling;
        //                 n --;
        //             }else {
        //                 elem = elem.nextSibling;
        //             }
        //         }
        //     }else if(n == 0) {
        //         elem = elem;
        //     }else {
        //         while(-n) {
        //             if(elem.previousSibling.nodeType == 1) {
        //                 elem = elem.previousSibling;
        //                 n ++;
        //             }else {
        //                 elem = elem.previousSibling;
        //             }
        //         }
        //     }
        //     return elem;
        // }
        // var em = document.getElementsByTagName('em')[1];
        //由于写这个函数的时候忘记了负数返回true, 所以下面做一下改进
        // function retSibling(elem, n) {
        //     while(elem && n) {
        //         if(n > 0) {
        //             if(elem.nextElementSibling || elem.nextElementSibling == null) {
        //                 elem = elem.nextElementSibling;  
        //             }else {
        //                 for(elem = elem.nextSibling; elem == null || elem.nodeType == 1; elem = elem.nextSibling);
        //             }
        //             n --;
        //         }else {
        //             if(elem.previousElementSibling || elem.previousElementSibling == null) {
        //                 elem = elem.previousElementSibling;
        //              }
        //              else {
        //                 for(elem = elem.previousSibling; elem == null || elem.nodeType == 1; elem = elem.previousSibling);
        //             }
        //             n ++;
        //         }
        //     }
        //     return elem;
        // }
        // var strong = document.getElementsByTagName('strong')[1];

        //编辑函数, 封装myChildren功能, 解决以前部分浏览器的兼容性问题
        // Element.prototype.myChildren = function() {
        //     var temp = [];
        //     var childArr = this.childNodes;
        //     for(var prop in childArr) {
        //         if(childArr[prop].nodeType == 1) {
        //             temp.push(childArr[prop]);
        //         }
        //     }
        //     return temp;
        // }


        //自己封装hasChildren()方法, 不可用children属性


        //封装一个函数, 给元素节点增加一个this-name属性, 属性值是nodeName
        // function thisName(elem) {
        //     elem.setAttribute('this-name', elem.nodeName);
        // }
        // var div = document.getElementsByTagName('div')[0];

        //课堂练习, 请编写一段JavaScript脚本生成下面这段DOM结构.要求: 使用标准得ODM方法或属性
        /*
            <div class="example">
                <p class="slogan">姬成, 你最帅!</p>
            </div>
        */
        // var div = document.createElement('div');
        // var p = document.createElement('p');
        // div.setAttribute('class', 'example');
        // p.setAttribute('class', 'slogan');
        // var text = document.createTextNode('姬成, 你最帅!');
        // p.appendChild(text);
        // div.appendChild(p);
        // document.body.appendChild(div);

        //封装一个函数insertAfter(); 功能类似于insertBefore();
        // Element.prototype.insertAfter = function(elemA, elemB) {
        //     var beforeElemB = elemB.nextelementSibling;
        //     if(beforeElemB) {
        //         this.insertBefore(elemA, beforeElemB);
        //     }else {
        //         this.appendChild(elemA);
        //     }
        //     return elemA;
        // }
        // var div = document.getElementsByTagName('div')[0];
        // var span = document.getElementsByTagName('span')[0];
        // var em = document.createElement('em');
        // var strong = document.getElementsByTagName('strong')[0];


        //将一个目标节点内部的节点逆序
        // function reverseNodes(elem) {
        //     var childArr = elem.childNodes,
        //         len = childArr.length;
        //     for(var i = len - 1; i >= 0; i --) {
        //         elem.appendChild(childArr[i]);
        //     }
        //     return elem;
        // }
        // var div = document.getElementsByTagName('div')[0];


    </script>
</body>
</html>